# Overview

## 목표 설정하기

항상 일을 시작하기에 앞서서 목표를 명확하게 설정하는 것이 중요합니다.

저희의 추상적인 1차 목표는 **재미있고 돈을 많이 버는 게임**을 만드는 것입니다.<br>
이 추상적인 목표를 조금씩 구체화 시켜나가도록 하겠습니다.

**재미와 돈** 이라는 추상적인 목표는 누구도 명확하게 정의 할 수가 없습니다. 재미라는 것이 주관적인 요소이고 그 주관적인 요소를 가지고 불특정 다수를 만족시키면서 돈을 버는 방법을 찾는 다는 것은 쉬운 일이 아닙니다. 재미있는 게임, 돈을 버는 게임이라는 것을 정의하고 기획 할 수 있다면 그 사람의 연봉과 기업 가치는 수천억을 상회할 것 같습니다. ^^;;

그럼에도 불구하고 게임은 계속 쏟아져 나오고 성공을 하고 실패를 반복합니다. 매일 앱스토어에 등록되는 수천, 수만의 게임들을 보면 수만 번의 실패 끝에 한번의 성공으로 바도 무방할 것 같습니다.

게임은 수만번의 시도 끝에 창의적이고 다양한 아이디어를 가지고 유저를 만족 시키고 그에 상응하는 수익을 번다고 볼 수 있습니다. 그 시도는 기획자의 머리 속에서 일어 날 수도 있고, 사내 알파/베타 테스트를 통해 판단 하거나, 시장에서 직접 유저에게 판단을 받을 수도 있습니다. 물론 좋은 게임을 만들기 위해서는 게임의 방향성, 타케팅, 마케팅, 기획 능력, 그래픽등 다양한 요소들이 갖춰줘야 하지만 본 블로그는 개발자들(특히 프로그래머)들을 위한 내용으로써 개발 외적인 부분들은 같이 일하는 회사와 팀원을 믿고 최선을 다하고 있다고 생각합시다.(^^;)

요즘 게임 트렌드는 3개월에 마다 한번씩 바뀐다고 합니다. 3개월도 안되서 새로운 게임이 트렌드로 자리 잡고 또 3개월이 지나면 다른 장르와 다른 형태의 게임이 트랜드로 자리 잡습니다. 이와 같은 빠른 트렌드의 변화는 개발의 **생산성**이 매우 중요합니다.

이를 바탕으로 비즈니스 측면에서 보면 동일한 게임을 만드는데,<br>
1달간 500만원을 들여서 게임을 만드는 것과<br>
2주일간 1000만원 들여서 게임을 만드는 것<br>
당연히 후자를 택하게 됩니다. 돈을 두배로 쓰더라도 빨리 만들면 기회 비용이 더 커집니다. 좋은 게임이라도 트렌드를 못따라가면 망하기가 쉽습니다.

### 트렌드가 된 기술들은 왜 트렌드가 되었을가?

글 쓰는 시점 프론트엔드의 트렌드 기술은 angular, react, vue 3가지 정도입니다. 3가지 프레임워크를 비교해 보면 각자 장단점이 있지만 대부분 지원하는 기능은 동일합니다. 최근 들어서는 github 에서 vue 가 angular, react 를 제치고 1위를 하였습니다. 그럼 비슷함에도 불구하고 vue가 약진을 한 이유는 바로 생산성 때문입니다. 여기서 말하는 생산성이란 단순히 코드를 짜서 나오는 아웃풋뿐만 아니라 vue 를 시작하는데 처음 공부를 하는 러닝커브까지 포함입니다. vue는 다른 프레임워크에 비해서 빨리 배워서 빨리 쓸수 있게 만들어져 있습니다. 요즘은 아무리 좋은 프레임워크라도 러닝커브를 포함한 생산성이 떨어지면 트렌드 기술이 되기 쉽지 않습니다.

### 결론은 생산성

게임의 성공을 위해서 우리가 해야 하는 2차적인 목표는 **기술력과 빠른 생산성**입니다.<br>
기술력을 통해 창의적인 기획을 바로 개발이 가능하고 생산성을 통해 다양한 시도를 하고 빠른 결과를 낼 수 있게끔 하는 것입니다. 안타깝게도 **기술력이라는 것은 기술에서 나오는 것이 아니고 경험에서 나오는 것**이라 기술력이 없는 회사 입장에서 기술력을 키워나가기 보다는 그냥 기술력을 가진 사람을 뽑는 것이 수월하고 효율적입니다. (개인적인 의견입니다. 물론 기술력 좋은 사람이 온다고 다 해결 되지는 않습니다. 또한 회사 차원에서 사내 인재에 투자하고 기술을 쌓아 가는 편이 장기적으로 더 건전하지만 왠만한 자금력과 수뇌부의 인내심이 있지 않고서는 현실적으로 힘듭니다.) 안정성, 운영능력등은 다 기본적으로 수반되야 하는 것임으로 논의하지 않습니다.

장황하게 설명했지만, 사실 모든 한국 IT 업계의 요구 사항도 빠른 개발입니다. 그냥 매일 빨리빨리 개발해 달라고 하고 무리하게 일정잡고 그거 맞추려고 야근하는 것이 한국 IT의 현실이기도 합니다. (저희 회사가 그렇다는 것은 아닙니다. ^^;)

## 기술 선정하기

### 좋은 기술이란 무엇일가?

트렌드 기술? 생산성이 높은 기술? 러닝커브 낮은 기술? 관리 코스트가 낮은 기술?

#### 콘웨이의 법칙

> **Conway's Law**<br>
> Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.

1968년 멜빈 콘웨이는 “모듈 프로그래밍 국제 심포지움”에 가서 논문을 하나 발표합니다. 그 핵심 내용이 이렇습니다. 직역하면 "소프트웨어 구조는 해당 소프트웨어를 개발한 조직의 커뮤니케이션 구조를 닯게 된다." 라는 뜻인데 논문의 일부라서 좀 풀어서 쉽게 제가 해석하자면 "기술이 조직구조에 종속되게 된다"는 뜻입니다.

기술이 조직구조에 종속된다고? 이게 말이야? 말밥이야? 하실 수 있는데 더 풀어서 설명을 하겠습니다.

A라는 조직이 서버팀/웹팀/디비팀 으로 운영을 한다고 하면,<br>
각 팀은 자기 팀에 맞는 최적화된 기술을 찾고 개발하게 됩니다. 서버는 백엔드 기술을, 웹팀은 프론트엔드 기술을, 디비팀은 디비에 집중 할 수 있는 기술을 사용합니다. 사람을 뽑을 때도 각 팀에 맞는 기술에 해당 하는 사람을 채용하게 됩니다.

B라는 조직은 프로그램팀을 하나로 운영합니다.<br>
B조직에서는 서버/웹/디비의 경계선이 없이 Full Stack 기반의 개발을 합니다. 당연히 사용하는 기술은 Full Stack 기반의 프레임워크를 사용하며 사람을 채용 할때도 프론트엔드와 백엔드를 같이 할 수 있는 사람을 채용합니다.

그냥 얼핏봐서는 그냥 무조건 다 할 줄 아는 사람 뽑아서 하나로 운영하면 되는거 아니냐 할 수도 있는데, 조직의 구조는 개인이 결정 할 수 있는 부분이 아니기 때문에 쉬운 문제가 아닙니다. 이미 조직이 3 Tear 방식으로 운영하고 있다고 하면 기존 개발자들을 다 재교육을 시켜야 하기 때문에 Full Stack 으로의 전환은 더 힘들게 됩니다. 게임 개발에 있어서도 서버/클라이언트팀을 딱 나누어 놓으면 생산성을 올리기 위해서 Full Stack 처럼 Data driven 개발 방식을 적용 하고 싶어도 서버는 서버만, 클라이언트는 앱만 처다보게 됩니다.

간단히 정리하면 좋은 기술이 있다고 쓰는 것이 아니고 조직에 맞는 기술을 맞춰서 쓸 수 밖에 없게 되기 때문에 기술을 선정함에 있어서도 조직 구조와 역량을 잘 파악해야 하고 팀에서 잘 활용 할 수 있는 기술을 선정해야 합니다.

### 우리 기술 선정 기준

저희 팀은 중기 프로젝트 1개와 단기 프로젝트 여러개를 동시에 개발을 하며 개발 사이클이 짧은 편입니다. 작은 규모 팀이라 한 사람이 여러 프로젝트를 담당해야 함으로 운영 및 관리 코스트도 낮아야 합니다. 이와 같은 상황에서 기술 선정을 위해 다음과 같은 키워드로 정리됩니다.

**Serverless**: 빠른 생산성과 서버 비용, 운영 및 관리 코스트의 절감<br>
**Module(Component) Base**: 모듈 단위 재활용성과 동시 유지 보수<br>
**Micro Service**: 서비스 단위 재활용성과 확장성<br>
**Data Driven**: 클라이언트 주도의 개발 생산성<br>
**협업**: 웹 기반의 통합 허브를 통한 개발 생산성 향상 및 관리 코스트 절감<br>

DevOps나 Agile 등은 필수 사항입니다.

## 우리가 사용하는 기술 스택

::: warning
아직 작성중입니다.
:::

### SCM & Package 관리

Git: gitflow, [Conventional Commits](https://www.conventionalcommits.org)

Git Service:
* Github: (public)오픈 소스 repo
* Gitlab: (private) 프로젝트 repo

> Github 유료로 통합 하면 좋지만 비용 절감을 위해 public/private repo 를 나눠서 사용중

npm: 오픈 소스 모듈 등록

yarn: 패키지 관리

[leana](https://lernajs.io/): 모듈 버전 관리 및 Chage History

### DevOps

travis: github open source project

gitlab-ci: private project

docker: ci/cd

### Cloud

Firebase: 프로젝트 메인
* Auth: 인증
* Realtime Database: 채팅 및 간단한 실시간 기능
* Firestore: 메인 Database
* Analytics: 앱 이벤트
* Hosting: 간단한 웹 어드민

> 앱 이벤트를 위해서 클라가 다중으로 Facebook, appsflyer 등을 사용하고 있지만 Firebase Analytics 가 raw 데이터 접근이 가능하여 차후 다양한 분석이 가능함

GCP: IO 서버 및 Schduler

> Firebase 는 frequency 높은 실시간 io 처리가 부적합하여 GCP를 활용하여 io 서버 구축<br>

AWS: Lambda, GameLift

> Firebase에 스케줄러 기능이 없어서 스케줄링이 필요한 경우 사용<br>
> Dedicated Server 방식의 게임 개발에 활용<br>

### API

express: 오래 된 프로젝트

Graphql: 신규 프로젝트

### Web

vue: quasar 를 위한 기반 지식, 순수 vue 를 사용 하지 않음

quasar: vue 기반 css 내장 프레임워크

### Engine

unity

### Docs

swagger: rest api

graphql: graphql api

lerna: Change History

vuepress: wiki

### Language

Javascript, Typescript, python, c#(Unity), Java(android native), swift(iOS Native)

> 기본적으로 Node 기반 개발<br>
> Java 및 swift 는 Unity Native 플러그인 개발에만 사용

### Misc

생산성 향상, 비용 및 관리 코스트를 줄이기 위해 모든 서버는 기본 적으로 Serverless<br>
단, session 을 유지해야 하는 io 서버 제외<br>
Data Driven 개발 방식을 위해 기본적으로 NoSQL 사용<br>
Aggregation 필요한 경우 Big Query 또는 RDB 사용






